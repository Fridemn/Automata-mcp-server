# Automata MCP Server - 工具适配规范

## 概述

Automata MCP Server 是一个基于 FastAPI 的 MCP (Model Context Protocol) 服务器，采用插件式架构。本文档详细说明如何编写符合规范的工具，以便被系统自动发现和加载。

## 目录结构要求

### 1. 工具目录位置

工具可以放置在以下两个目录中的任意一个：

- **主工具目录**: `app/src/`（通过环境变量 `TOOLS_DIR` 可配置，默认为 `src`）
- **扩展工具目录**: `app/AutoUp-MCP-Extension/`

### 2. 工具包结构

每个工具必须是一个独立的 Python 包，遵循以下结构：

```
app/src/
└── your_tool_name/              # 工具包目录
    ├── __init__.py              # 必需：包初始化文件
    ├── your_tool_name_tool.py   # 必需：工具实现文件
    └── config.yaml              # 可选：工具配置文件
```

**关键规范：**
- 工具目录名称：使用小写字母和下划线（snake_case），如 `fetch`、`polish`、`video_generate`
- 工具文件名称：必须为 `{工具目录名}_tool.py`
- 类名：必须为 `{工具目录名的驼峰式}Tool`

**命名对应示例：**
```
目录名: fetch          → 文件名: fetch_tool.py       → 类名: FetchTool
目录名: polish         → 文件名: polish_tool.py      → 类名: PolishTool
目录名: video_generate → 文件名: video_generate_tool.py → 类名: VideoGenerateTool
目录名: sm_auth        → 文件名: sm_auth_tool.py    → 类名: SmAuthTool
```

## 文件详细说明

### 1. `__init__.py` 文件

**作用**: 将目录标识为 Python 包，并导出工具类

**标准模板**:
```python
from .{your_tool_name}_tool import {YourToolName}Tool

__all__ = ["{YourToolName}Tool"]
```

**示例**:
```python
# app/src/fetch/__init__.py
from .fetch_tool import FetchTool

__all__ = ["FetchTool"]
```

### 2. `{your_tool_name}_tool.py` 文件

**作用**: 实现工具的核心逻辑

**必需继承**: `BaseMCPTool` 抽象基类

**必需实现的方法**:

#### 2.1 `__init__(self)`
初始化工具实例

```python
def __init__(self):
    super().__init__()
    # 初始化工具所需的资源，如 LLM 客户端、数据库连接等
```

#### 2.2 `get_route_config(self) -> list[dict]`
定义工具的 FastAPI 路由配置

**返回值**: 字典列表，每个字典包含以下键：

| 键 | 类型 | 必需 | 说明 |
|---|---|---|---|
| `endpoint` | str | 是 | API 路径，如 `"/tools/fetch"` |
| `params_class` | BaseModel | 是 | Pydantic 参数模型类 |
| `use_form` | bool | 否 | 是否使用表单数据，默认 False（使用 JSON） |
| `tool_name` | str | 否 | 工具名称，默认为目录名 |

**示例**:
```python
def get_route_config(self) -> list[dict]:
    return [
        {
            "endpoint": "/tools/fetch",
            "params_class": FetchParams,
        }
    ]

# 使用表单数据（支持文件上传）
def get_route_config(self) -> list[dict]:
    return [
        {
            "endpoint": "/tools/polish",
            "params_class": PolishParams,
            "use_form": True,  # 启用表单数据
        }
    ]

# 多个端点
def get_route_config(self) -> list[dict]:
    return [
        {
            "endpoint": "/tools/video/generate",
            "params_class": GenerateParams,
            "tool_name": "video_generate",
        },
        {
            "endpoint": "/tools/video/subtitle",
            "params_class": SubtitleParams,
            "tool_name": "video_subtitle",
        }
    ]
```

#### 2.3 `async def list_tools(self) -> list[Tool]`
列出工具提供的 MCP 工具

**返回值**: `Tool` 对象列表

```python
async def list_tools(self) -> list[Tool]:
    return [
        Tool(
            name="fetch",
            description="Fetches a URL and extracts its contents as markdown.",
            inputSchema=FetchParams.model_json_schema(),
        )
    ]
```

#### 2.4 `async def call_tool(self, name: str, arguments: dict) -> Sequence[TextContent | ImageContent | EmbeddedResource]`
执行工具调用

**参数**:
- `name`: 工具名称
- `arguments`: 参数字典

**返回值**: 内容序列（TextContent、ImageContent 或 EmbeddedResource）

**标准实现模式**:
```python
async def call_tool(
    self,
    name: str,
    arguments: dict,
) -> Sequence[TextContent | ImageContent | EmbeddedResource]:
    # 1. 验证工具名称
    if name != "your_tool_name":
        raise ValueError(f"Unknown tool: {name}")

    # 2. 验证和解析参数
    try:
        args = YourParamsClass(**arguments)
    except ValueError as e:
        raise McpError(ErrorData(code=INVALID_PARAMS, message=str(e)))

    # 3. 执行工具逻辑
    try:
        result = await self.perform_action(args)
    except Exception as e:
        raise McpError(
            ErrorData(code=INTERNAL_ERROR, message=f"Failed to execute: {e}")
        )

    # 4. 返回结果
    return [TextContent(type="text", text=result)]
```

### 3. 参数模型（Pydantic BaseModel）

**作用**: 定义工具的输入参数

**要求**: 继承 `pydantic.BaseModel`

**示例**:
```python
from pydantic import BaseModel, Field, AnyUrl

class FetchParams(BaseModel):
    url: AnyUrl = Field(description="URL to fetch")
    max_length: int = Field(
        default=5000,
        description="Maximum number of characters to return.",
        gt=0,
        lt=1000000,
    )
    start_index: int = Field(
        default=0,
        description="Starting character index for output.",
        ge=0,
    )
    raw: bool = Field(
        default=False,
        description="Get raw HTML without simplification.",
    )
```

**支持的字段类型**:
- 基本类型: `str`, `int`, `float`, `bool`
- 复杂类型: `list`, `dict`, `AnyUrl`
- 文件上传: `UploadFile`（需要设置 `use_form=True`）

### 4. `config.yaml` 文件（可选）

**作用**: 配置工具的元数据和依赖

**标准格式**:
```yaml
enabled: true
description: "工具的简要描述"
usage: "使用说明和参数说明"
packages:
  - "package1==version"
  - "package2==version"
```

**字段说明**:

| 字段 | 类型 | 说明 |
|---|---|---|
| `enabled` | bool | 是否启用（当前未使用，但建议保留） |
| `description` | str | 工具描述 |
| `usage` | str | 使用说明 |
| `packages` | list | Python 依赖包列表，会在启动时自动安装 |

**示例**:
```yaml
# app/src/fetch/config.yaml
enabled: true
description: "通用网页内容获取工具，用于抓取和解析网页内容"
usage: "传入 url (网页URL), max_length (最大字符数，默认5000), start_index (起始索引，默认0), raw (是否获取原始HTML，默认false)"
packages:
  - "requests==2.31.0"
  - "httpx==0.27.2"
  - "markdownify==0.14.1"
  - "readabilipy==0.2.0"
  - "protego==0.3.1"
```

## 完整示例

### 示例 1: 简单的文本处理工具

**目录结构**:
```
app/src/
└── text_counter/
    ├── __init__.py
    ├── text_counter_tool.py
    └── config.yaml
```

**`__init__.py`**:
```python
from .text_counter_tool import TextCounterTool

__all__ = ["TextCounterTool"]
```

**`text_counter_tool.py`**:
```python
from typing import Sequence
from pydantic import BaseModel, Field
from mcp.types import Tool, TextContent, ImageContent, EmbeddedResource
from mcp.shared.exceptions import McpError
from mcp.types import INVALID_PARAMS, INTERNAL_ERROR, ErrorData
from app.base_tool import BaseMCPTool


class TextCounterParams(BaseModel):
    text: str = Field(description="要统计的文本")


class TextCounterTool(BaseMCPTool):
    def __init__(self):
        super().__init__()

    def get_route_config(self) -> list[dict]:
        return [
            {
                "endpoint": "/tools/text_counter",
                "params_class": TextCounterParams,
            }
        ]

    async def list_tools(self) -> list[Tool]:
        return [
            Tool(
                name="text_counter",
                description="统计文本的字符数和单词数",
                inputSchema=TextCounterParams.model_json_schema(),
            )
        ]

    async def call_tool(
        self,
        name: str,
        arguments: dict,
    ) -> Sequence[TextContent | ImageContent | EmbeddedResource]:
        if name != "text_counter":
            raise ValueError(f"Unknown tool: {name}")

        try:
            args = TextCounterParams(**arguments)
        except ValueError as e:
            raise McpError(ErrorData(code=INVALID_PARAMS, message=str(e)))

        char_count = len(args.text)
        word_count = len(args.text.split())

        result = f"字符数: {char_count}, 单词数: {word_count}"

        return [TextContent(type="text", text=result)]
```

**`config.yaml`**:
```yaml
enabled: true
description: "文本统计工具，统计字符数和单词数"
usage: "传入 text (要统计的文本)"
packages: []  # 不需要额外依赖
```

### 示例 2: 带文件上传的工具

**`file_analyzer_tool.py`**:
```python
from typing import Sequence
from pydantic import BaseModel, Field
from fastapi import UploadFile
from mcp.types import Tool, TextContent, ImageContent, EmbeddedResource
from mcp.shared.exceptions import McpError
from mcp.types import INVALID_PARAMS, INTERNAL_ERROR, ErrorData
from app.base_tool import BaseMCPTool


class FileAnalyzerParams(BaseModel):
    file: UploadFile = Field(description="要分析的文件")
    detail_level: str = Field(default="basic", description="分析详细程度: basic/detailed")


class FileAnalyzerTool(BaseMCPTool):
    def __init__(self):
        super().__init__()

    def get_route_config(self) -> list[dict]:
        return [
            {
                "endpoint": "/tools/file_analyzer",
                "params_class": FileAnalyzerParams,
                "use_form": True,  # 启用表单数据以支持文件上传
            }
        ]

    async def list_tools(self) -> list[Tool]:
        return [
            Tool(
                name="file_analyzer",
                description="分析上传文件的内容",
                inputSchema=FileAnalyzerParams.model_json_schema(),
            )
        ]

    async def call_tool(
        self,
        name: str,
        arguments: dict,
    ) -> Sequence[TextContent | ImageContent | EmbeddedResource]:
        if name != "file_analyzer":
            raise ValueError(f"Unknown tool: {name}")

        try:
            args = FileAnalyzerParams(**arguments)
        except ValueError as e:
            raise McpError(ErrorData(code=INVALID_PARAMS, message=str(e)))

        # 读取文件内容
        content = await args.file.read()

        # 分析文件
        result = f"文件名: {args.file.filename}\n"
        result += f"大小: {len(content)} 字节\n"
        result += f"详细程度: {args.detail_level}"

        return [TextContent(type="text", text=result)]
```

## 自动加载流程

系统启动时会自动执行以下流程：

1. **依赖安装阶段** (`install_dependencies_for_enabled_tools`):
   - 扫描工具目录（`app/src/` 和 `app/AutoUp-MCP-Extension/`）
   - 对每个包含 `__init__.py` 的子目录：
     - 读取 `config.yaml`（如果存在）
     - 提取 `packages` 列表
     - 使用 `uv pip install` 安装依赖

2. **工具发现阶段** (`discover_tools`):
   - 扫描工具目录
   - 对每个包含 `__init__.py` 的子目录：
     - 检查是否存在 `{目录名}_tool.py` 文件
     - 动态导入模块（如 `app.src.fetch.fetch_tool`）
     - 查找工具类（如 `FetchTool`）
     - 实例化工具类
     - 注册到工具字典

3. **路由注册阶段** (`register_tool_routes`):
   - 调用工具的 `get_route_config()` 方法
   - 为每个路由配置创建 FastAPI 端点
   - 注入 API Key 认证依赖
   - 注册到 FastAPI 应用

## 导入语句规范

在工具文件中，需要导入以下核心依赖：

```python
# 基础工具类
from app.base_tool import BaseMCPTool

# MCP 类型
from mcp.types import (
    Tool,
    TextContent,
    ImageContent,
    EmbeddedResource,
    INVALID_PARAMS,
    INTERNAL_ERROR,
    ErrorData,
)

# 异常处理
from mcp.shared.exceptions import McpError

# 参数验证
from pydantic import BaseModel, Field

# 类型提示
from typing import Sequence

# 文件上传（如需要）
from fastapi import UploadFile
```

## 常见问题

### 1. 工具没有被加载？

检查以下几点：
- [ ] 目录下是否有 `__init__.py` 文件
- [ ] 工具文件名是否为 `{目录名}_tool.py`
- [ ] 类名是否为正确的驼峰式 `{目录名}Tool`
- [ ] 是否继承了 `BaseMCPTool`
- [ ] 是否实现了所有必需方法
- [ ] 查看服务器日志中的错误信息

### 2. 依赖包安装失败？

- 检查 `config.yaml` 中的 `packages` 格式是否正确
- 确保包名和版本号使用 `==` 分隔
- 检查网络连接和 PyPI 访问
- 查看终端日志中的详细错误信息

### 3. 路由注册失败？

- 确保 `get_route_config()` 返回正确的字典或字典列表
- 检查 `endpoint` 是否以 `/` 开头
- 确保 `params_class` 是有效的 Pydantic 模型
- 验证端点路径是否与其他工具冲突

### 4. 文件上传不工作？

- 确保设置了 `use_form=True`
- 参数模型中使用 `UploadFile` 类型
- 从 `fastapi` 导入 `UploadFile`：`from fastapi import UploadFile`

### 5. 如何调试工具？

- 查看服务器启动日志，搜索工具名称
- 使用 `logger.info()` 添加调试信息
- 访问 `/tools` 端点查看已注册的工具列表
- 使用 API 客户端测试工具端点

## API 调用示例

工具注册后，可以通过 HTTP POST 请求调用：

```bash
# JSON 请求
curl -X POST http://localhost:8000/tools/fetch \
  -H "Content-Type: application/json" \
  -H "X-API-Key: your-api-key" \
  -d '{
    "url": "https://example.com",
    "max_length": 5000,
    "start_index": 0,
    "raw": false
  }'

# 表单请求（带文件上传）
curl -X POST http://localhost:8000/tools/file_analyzer \
  -H "X-API-Key: your-api-key" \
  -F "file=@/path/to/file.txt" \
  -F "detail_level=detailed"
```

## 环境变量配置

在 `.env` 文件中可配置：

```env
# API 认证密钥（可选，不设置则不需要认证）
AUTOMATA_API_KEY=your-secret-key

# 服务器配置
HOST=0.0.0.0
PORT=8000

# 工具目录（可选，默认为 src）
TOOLS_DIR=src
```

## 最佳实践

1. **命名规范**: 始终使用小写+下划线命名目录，系统会自动转换为正确的类名
2. **错误处理**: 使用 `McpError` 包装所有错误，提供清晰的错误信息
3. **参数验证**: 充分利用 Pydantic 的验证功能，使用 `Field` 添加描述和约束
4. **异步支持**: 所有工具方法都应该是异步的（`async def`）
5. **依赖管理**: 在 `config.yaml` 中明确列出所有依赖及版本
6. **文档完善**: 在工具描述、参数描述中提供清晰的说明
7. **日志记录**: 适当使用 `logger` 记录关键操作和错误
8. **资源清理**: 在工具中正确管理资源（文件、连接等），必要时实现清理逻辑

## 总结

要创建一个可被自动加载的工具，需要：

✅ **必需文件**:
- `__init__.py` - 导出工具类
- `{tool_name}_tool.py` - 实现工具逻辑

✅ **必需遵循**:
- 目录名与文件名的对应关系
- 继承 `BaseMCPTool`
- 实现所有抽象方法
- 正确的类命名（驼峰式）

✅ **可选增强**:
- `config.yaml` - 配置依赖和元数据

按照此规范创建工具后，只需将工具目录放入 `app/src/` 或 `app/AutoUp-MCP-Extension/`，重启服务器即可自动加载！
